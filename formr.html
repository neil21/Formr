<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/ef5f05d71bb33e5811560851547fe4f0bc33e153/build/three.min.js"></script>
    <script type="text/javascript" src="http://dat-gui.googlecode.com/git-history/a3ae8c6627d23c19a140dd2dcadce48375562877/build/dat.gui.min.js"></script>	
    <script src="scripts/ColladaLoader.js"></script>
    <title>Formr</title>
  </head>
  <body>
  
  <p style="display:block;margin:0 auto;font-family:helvetica, arial, sans-serif;font-size:smaller">arrow keys to move, a bit</p>
  
<script>

/*
To do:

better camera (standard ones messed with dat.gui: maybe just need specific div for rendering to)
"add lots" button
"vary lot size" slider
createLane button
individual lane widths, heights and colours
different floor heights
sloped top floor (roof)
add textures
add trees, cars, people, bikes to street (I'm imagining a single 3D model of each imported from sketchup)
individual building control - perhaps like cubistan with a selection ray (also include a "select all" button)
*/

var camera, scene, renderer, controls;
var geometry, material, mesh;

// pass these to createLane
var laneheight = 0.02;
var curbheight = 0.05;
var streetlength = 200;

//constructor sizes - need defaults to do scaling
var defaultlanewidth = 3.6; //metres
var defaultlotwidth = 15;
var defaultlotdepth = 20;

var defaultfrontsetback = 1;
var defaultrearsetback = 5;
var defaultsidesetback = 2;

var defaultnumberfloors = 3;
//metres (2m carpet to ceiling plus 0.5m insulation, piping etc.)
var defaultfloorheight = 2.5;
var groundfloorextraheight = 1; //metres
// metres - negative "extra" just to keep the math consistent;
// we'll worry about sloping later
var topfloorextraheight = -1;

var defaultbuildingfrontage = defaultlotwidth - (2 * defaultsidesetback);
var defaultbuildingdepth = defaultlotdepth - defaultfrontsetback - defaultrearsetback;

var totalstreetwidth,
		total_left_streetwidth,
		total_right_streetwidth,
		total_left_lotslength,
		total_right_lotslength; //for correct lot placement
var street = [];
var lots = [];
var buildings = [];
var params = {
	lanewidthparameter: defaultlanewidth,
	sidesetbackparameter: defaultsidesetback,
	rearsetbackparameter: defaultrearsetback,
	frontsetbackparameter: defaultfrontsetback,
	floorsparameter: defaultnumberfloors
}

var i; //for loops

//constants for positioning lanes;
var LEFTSIDE = 1;
var RIGHTSIDE = -1;

	init();
	animate();

var gui = new dat.GUI();
var lanecontroller = gui.add(params, 'lanewidthparameter', 1.5, 5, 0.1)
	 //type, variable name, min (1.5m sidewalk), max (5m woonerf?), step
	.name("Lane Width")
	.onChange(laneUpdate) 
		
function laneUpdate () {
	total_right_streetwidth = 0;
	total_left_streetwidth = 0;
	//totalstreetwidth = 0;

	for (i=0; i < street.length; i++){
		//slightly confusing nomenclature: street.length is just
		//the number of lanes (so really more akin to street width)
		//since street[] is an array of lanes
		street[i] = updateLane(street[i], params.lanewidthparameter);
		if(street[i].laneSide == LEFTSIDE){
			total_left_streetwidth += street[i].laneWidth; //keep track of total street width
		} else {
			total_right_streetwidth += street[i].laneWidth;
		}
	}

	newtotalstreetsidewidth = 0 ;
	for (i=0; i < lots.length; i++){
		if(lots[i].side == LEFTSIDE){
			newtotalstreetsidewidth = total_left_streetwidth;
		} else {
			newtotalstreetsidewidth = total_right_streetwidth;
		}
		lots[i] = updateLot(lots[i], newtotalstreetsidewidth);
	}

}

var sidesetbackcontroller = gui.add(params, 'sidesetbackparameter', 0, defaultlotwidth/2, 0.1)
	.name("Side Setback");
sidesetbackcontroller.onChange( function() {
	for (i=0; i < buildings.length; i++){
		updateSidesetback(buildings[i], params.sidesetbackparameter);
	}
});

var rearsetbackcontroller = gui.add(params, 'rearsetbackparameter', 0, defaultlotdepth, 0.1)
	.name("Rear Setback");
rearsetbackcontroller.onChange( function() {
	for (i=0; i < buildings.length; i++){
		updateRearsetback(buildings[i], params.rearsetbackparameter);
	}
});

var frontsetbackcontroller = gui.add(params, 'frontsetbackparameter', 0, defaultlotdepth, 0.1)
	.name("Front Setback");
frontsetbackcontroller.onChange( function() {
	for (i=0; i < buildings.length; i++){
		updateFrontsetback(buildings[i], params.frontsetbackparameter);
	}
});

var floorscontroller = gui.add(params, 'floorsparameter')
	.min(0)
	.max(8)
	.step(1)
	.name("Floors");
floorscontroller.onChange( function(e) {
	for (i=0; i < buildings.length; i++){
		updateFloors(buildings[i], params.floorsparameter);
	}
});

/********** BUILDING ********************/

function v(x,y,z){ 
	return new THREE.Vertex(new THREE.Vector3(x,y,z)); 
}

function createBuilding(lot, frontsetback, rearsetback, sidesetback, floors){
	var depth = lot.depth - frontsetback - rearsetback; //20 - 1 - 5 = 14
	var frontage = lot.frontage - 2*sidesetback; //15 - 2*2
	var height = curbheight + (floors * defaultfloorheight); //0.05 + (3*2)
	geometry = new THREE.CubeGeometry(depth, height, frontage );
	var wallMaterial = new THREE.MeshBasicMaterial( { color: 0x111111*Math.random() } );
	material = new THREE.MeshBasicMaterial( { color: 0xE2725B , wireframe: true, transparent: false } );
	var floorGeom = new THREE.Geometry();
	var floorGridMaterial = new THREE.LineBasicMaterial( { color: 0xcccccc, opacity: 0.2 } );
	building = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material, wallMaterial]);
	building.position.y = curbheight/2 + height/2; //move it up to proper spot
/*
	var unbuilt = floors
		, level
		, floorgeom;
	while (unbuilt) {
		floorgeom = new THREE.CubeGeometry(depth, height/floors, frontage );
		floorgeom.dynamic = true;
		wallMaterial = new THREE.MeshBasicMaterial( { color: 0x1fffff*Math.random() } );
		var flr = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material, wallMaterial]);
		floorgeom.z = unbuilt*defaultfloorheight;
		THREE.GeometryUtils.merge(geometry, floorgeom);
		unbuilt--;
	}
*/
	//position building relative to z-origin (in and out) line: same z position, centre of lot
	//FUTURE: switch lanetype: different material
	//material = new THREE.MeshBasicMaterial( { color: 0xE2725B, wireframe: true } );
	//-3 is flush, so 0 is 3 from lot edge: a 14-deep object centered in a 20-deep lot
	building.position.x = -1 * lot.side * ((frontsetback+rearsetback)/2) + lot.side * frontsetback;
	//initialise properties
	building.side = lot.side; //which side of the street we're on
	building.frontsetback = frontsetback;
	building.rearsetback = rearsetback;
	building.sidesetback = sidesetback;
	building.floors = floors;
	building.frontage = frontage;
	building.depth = depth;
	building.height = height;

	return building;
}

function updateSidesetback(building, newsidesetback){

	//var oldLaneWidth = lane.laneWidth;
	var newbuildingfrontage = building.frontage + 2 * (building.sidesetback - newsidesetback);

	//scale is always relative to the constructor size
	building.scale.z = newbuildingfrontage/defaultbuildingfrontage;
	//lane.position.x += lane.laneSide*(newLaneWidth-oldLaneWidth)/2;

	return building;
}

function updateFrontsetback(building, newfrontsetback){

	var oldbuildingdepth = building.depth;
	var newbuildingdepth = oldbuildingdepth + building.frontsetback - newfrontsetback;

	//scale is always relative to the constructor size
	building.scale.x = newbuildingdepth/defaultbuildingdepth;
	building.position.x += -building.side * (newbuildingdepth-oldbuildingdepth)/2;

	//update properties
	building.frontsetback = newfrontsetback;
	building.depth = newbuildingdepth;

	return building;
}


function updateRearsetback(building, newrearsetback){

	var oldbuildingdepth = building.depth;
	var newbuildingdepth = oldbuildingdepth + building.rearsetback - newrearsetback;

	//scale is always relative to the constructor size
	building.scale.x = newbuildingdepth/defaultbuildingdepth; 
	building.position.x += building.side * (newbuildingdepth-oldbuildingdepth)/2;

	/*
	lane.scale.x = newLaneWidth/defaultlanewidth; //scale is always relative to the constructor size
	lane.position.x += lane.laneSide*(newLaneWidth-oldLaneWidth)/2;
	*/

	//update properties
	building.rearsetback = newrearsetback;
	building.depth = newbuildingdepth;

	return building;
}

function updateFloors(building, newfloors){
	var oldbuildingheight = building.height;
	var newbuildingheight = newfloors * defaultfloorheight;

	building.scale.y = newbuildingheight/(defaultfloorheight * defaultnumberfloors);
	building.position.y += (newbuildingheight - oldbuildingheight) / 2;

	//update properties
	building.floors = newfloors;
	building.height = newbuildingheight;

	return building;
}

function updateBuilding(building,frontsetback, rearsetback, sidesetback, floors){
	return building;
}


/*********** LOTS ******************/

function createLot(frontage, depth, side){

	geometry = new THREE.CubeGeometry( depth, curbheight, frontage );

	//FUTURE: switch lanetype: different material
	material = new THREE.MeshBasicMaterial( { color: 0x526F35, wireframe: true } );

	lot = new THREE.Mesh(geometry, material);

	lot.position.y = curbheight/2;
	//append to one side or the other of the street - note that totalstreetwidth is global
	lot.position.x = side * ((totalstreetwidth/2)+(depth/2));

	if(side == RIGHTSIDE)
	{
		lot.position.x = side * (total_right_streetwidth + depth/2); //append to one side or the other of the street
		//z position is in centre of lot, so total_lotslength gets you to near edge,
		//then add half width to position centre
		lot.position.z = -1 * (total_right_lotslength + frontage/2);
		total_right_lotslength += frontage;
	} else {
		//append to one side or the other of the street
		lot.position.x = side * (total_left_streetwidth + depth/2);
		lot.position.z = -1 * (total_left_lotslength + frontage/2);
		total_left_lotslength += frontage;
	}

	//initialise properties
	lot.frontage = frontage;
	lot.depth = depth;
	lot.side = side;

	//create a building on it
	var i = 0;
	if (buildings.length != 0){
		i = buildings.length;
	}
	//lot, frontsetback, rearsetback, sidesetback, floors
	buildings[i] = new createBuilding(lot,defaultfrontsetback,defaultrearsetback,defaultsidesetback,defaultnumberfloors);
	lot.add(buildings[i]);

return lot;
//while adding lots, append this lot's frontage to running total of prior frontages
}

function updateLot(lot, newstreetsidewidth){
	lot.position.x = lot.side * (newstreetsidewidth+(lot.depth/2)); //append to one side or the other of the street
	return lot;
}


/*********** LANES ******************/

function createLane(lanewidth, side, totalsidewidth, height){

	geometry = new THREE.CubeGeometry( lanewidth, height, streetlength );

	//FUTURE: switch lanetype: different material
	material = new THREE.MeshBasicMaterial( { color: 0xf1f1f1, wireframe: true } );

	lane = new THREE.Mesh(geometry, material);
	lane.position.y = height/2;
	//append to one side or the other of the street
	lane.position.x = side * ( (lanewidth/2) + totalsidewidth );
	lane.position.z = -streetlength/2; // push street back to the origin

	//initialise properties
	lane.laneWidth = lanewidth;
	lane.laneSide = side;

return lane;
}

function updateLane(lane, newLaneWidth){

	// https://github.com/mrdoob/three.js/issues/1931

	var oldLaneWidth = lane.laneWidth;

	lane.scale.x = newLaneWidth/defaultlanewidth; //scale is always relative to the constructor size
	//add previous total side width
	var totalsidelaneswidth = 0;
	if ( lane.laneSide == LEFTSIDE ) {
		totalsidelaneswidth = total_left_streetwidth;
	} else {
		totalsidelaneswidth = total_right_streetwidth;
	}
	var userX = lane.laneSide * ( totalsidelaneswidth + newLaneWidth/2 );
	if (typeof lane.daeModel != 'undefined' && lane.daeModel) {
			for (var k = 0; k < lane.daeModel.length; k++) {
				lane.daeModel[k].position.x = userX;
		}
	}
	lane.position.x = userX; //append to one side or the other of the street

	lane.laneWidth = newLaneWidth; //update lanewidth property to match new setting

	return lane;

}

///////////////////////////////////////////////////////////////////////////
//end lanes
///////////////////////////////////////////////////////////////////////////


	function init() {
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = 30;
		camera.position.y = 6;

	/*
	controls = new THREE.FlyControls(camera);
	controls.movementSpeed = 0.1;
	controls.rollSpeed = 0;
	//controls.dragToLook = true;
	*/

			scene = new THREE.Scene();

	total_right_streetwidth = 0;
	total_left_streetwidth = 0;
	totalstreetwidth = 0;

	street[0] = new createLane(defaultlanewidth, RIGHTSIDE, total_right_streetwidth, laneheight);
	//defaultlanewidth/2
	total_right_streetwidth += street[0].laneWidth;
	street[1] = new createLane(defaultlanewidth, LEFTSIDE, total_left_streetwidth, laneheight);
	//-defaultlanewidth/2
	total_left_streetwidth += street[1].laneWidth;
	street[2] = new createLane(defaultlanewidth, RIGHTSIDE, total_right_streetwidth, laneheight);
	//-defaultlanewidth/2
	total_right_streetwidth += street[2].laneWidth;
	street[3] = new createLane(defaultlanewidth, LEFTSIDE, total_left_streetwidth, laneheight);
	//-defaultlanewidth/2
	total_left_streetwidth += street[3].laneWidth;
	//-defaultlanewidth/2
	street[4] = new createLane(defaultlanewidth, RIGHTSIDE, total_right_streetwidth, curbheight);
	total_right_streetwidth += street[4].laneWidth;
	//-defaultlanewidth/2
	street[5] = new createLane(defaultlanewidth, LEFTSIDE, total_left_streetwidth, curbheight);
	total_left_streetwidth += street[5].laneWidth;

	totalstreetwidth = total_right_streetwidth + total_left_streetwidth;

	for (i=0; i < street.length; i++){
		scene.add( street[i] );
	}

	function edgeAlternate () {
		// alternating curbs, indexed 4, 5 at edges by createLanes
		if (Math.random() < .5) return 4;
		return 5;
	}

	//sketchupLoader().load('models/persona.dae', 
	var sketchupLoader = function () { return new THREE.ColladaLoader(); }
	var daeModels = ['models/persona.dae', 'models/cyclist.dae'] //, 'models/Arbol.dae'];
	var daeModelScales = [.025, .025] //, .00051];
	var totalModels = 5;
			
	function loadDae (collada, frontZ, scale) {
		var model = collada.scene;
		model.scale.set(scale, scale, scale);
		model.rotation.x = -Math.PI/2;
		model.position.x = street[4].position.x
		model.position.z = frontZ || (-1) * Math.random()*streetlength/3;
		var edge = edgeAlternate();
		street[edge].daeModel? street[edge].daeModel.push(model)
			: street[edge].daeModel = [model];
		//THREE.GeometryUtils.merge(street[4].geometry, model.geometry);
		//scene.add(collada);
		scene.add(model);
		laneUpdate();
	}


	// always have at least one sketchup lady at front:
	sketchupLoader().load('models/persona.dae', function (collada) { 
		loadDae(collada, .001, 'models/persona.dae'); 
	});

	while (totalModels) {
		var randidx = Math.floor(Math.random()*daeModels.length)
		sketchupLoader().load(daeModels[randidx],
				function (collada) {
					var scale = daeModelScales[randidx];
					loadDae(collada, false, scale);
				});
		totalModels--;
	}
 
 /*	
	sketchupLoader().load('models/cyclist.dae', function (collada) {
		var model = collada.scene;
		model.scale.set(0.025, 0.025, 0.025);
		model.rotation.x = -Math.PI/2;
		model.position.x = street[5].position.x
		var abc ='d'
		street[5].daeModel = model
		console.log(model.position);
		scene.add(model);
		//scene.add(collada);
	});
*/

	total_left_lotslength = 0;
	total_right_lotslength = 0;

	var laneswitch = -1;
	var laneside = RIGHTSIDE;
	for (i=0; i < 10; i++) {
		lots[i] = new createLot(defaultlotwidth,defaultlotdepth,laneside);
		laneside = laneside * laneswitch; //leftlane, rightlane, leftlane...
	}

	for (i=0; i < lots.length; i++){
		scene.add( lots[i] );
	}

	container = document.createElement( 'div' );
	document.body.appendChild( container );

			renderer = new THREE.CanvasRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			container.appendChild( renderer.domElement );

	}

function animate() {
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	//controls.update(1);
}

function onDocumentKeyDown(event){
	var delta = 1;
	event = event || window.event;
	var keycode = event.keyCode;
	switch(keycode){
		case 37 : //left arrow
			event.preventDefault();
			camera.position.x = camera.position.x - delta;
			break;
		case 38 : // up arrow
			event.preventDefault();
			camera.position.z = camera.position.z - delta;
			break;
		case 39 : // right arrow
			event.preventDefault();
			camera.position.x = camera.position.x + delta;
			break;
		case 40 : //down arrow
			event.preventDefault();
			camera.position.z = camera.position.z + delta;
			break;
	}
	camera.updateProjectionMatrix();
}

document.addEventListener('keydown',onDocumentKeyDown,false);


</script>
  </body>
</html>
